{"version":3,"sources":["../../src/resolveComponentStyle.js"],"names":["resolveComponentStyle","isStyleVariant","propertyName","test","isChildStyle","splitStyle","style","reduce","result","value","key","styleSection","componentStyle","styleVariants","childrenStyle","customMerge","obj1","obj2","objToReturn","property1","property2","undefined","componentName","styleNames","themeStyle","parentStyle","themeCache","mergedStyle","forEach","sn","index","resolvedStyle"],"mappings":"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","file":"resolveComponentStyle.js","sourcesContent":["import _ from 'lodash';\n\n/**\n * Matches any style properties that represent component style variants.\n * Those styles can be applied to the component by using the styleName\n * prop. All style variant property names must start with a single '.'\n * character, e.g., '.variant'.\n *\n * @param propertyName The style property name.\n * @returns {boolean} True if the style property represents a component variant, false otherwise.\n */\nfunction isStyleVariant(propertyName) {\n  return /^\\./.test(propertyName);\n}\n\n/**\n * Matches any style properties that represent style rules that target the\n * component children. Those styles can have two formats, they can either\n * target the components by component name ('shoutem.ui.Text'), or by component\n * name and variant ('shoutem.ui.Text.line-through'). Beside specifying the\n * component name, those styles can also target any component by using the\n * '*' wildcard ('*', or '*.line-through'). The rule to identify those styles is\n * that they have to contain a '.' character in their name or be a '*'.\n *\n * @param propertyName The style property name.\n * @returns {boolean} True if the style property represents a child style, false otherwise.\n */\nfunction isChildStyle(propertyName) {\n  return /(^[^\\.].*\\.)|^\\*$/.test(propertyName);\n}\n\n/**\n * Splits the style into its parts:\n * component style - concrete style that needs to be applied to a component\n * style variants - variants that can be applied to a component by using styleName prop\n * children style - style rules that need to be propagated to component children\n *\n * @param style The style to split.\n * @returns {*} An object with the componentStyle, styleVariants, and childrenStyle keys.\n */\nfunction splitStyle(style) {\n  return _.reduce(style, (result, value, key) => {\n    let styleSection = result.componentStyle;\n    if (isStyleVariant(key)) {\n      styleSection = result.styleVariants;\n    } else if (isChildStyle(key)) {\n      styleSection = result.childrenStyle;\n    }\n    styleSection[key] = value;\n    return result;\n  }, {\n    componentStyle: {},\n    styleVariants: {},\n    childrenStyle: {},\n  });\n}\n\nfunction customMerge(obj1, obj2) {\n  const objToReturn = {};\n\n  let property1, property2;\n\n  if(!obj1) {\n    return obj2;\n  } else if(!obj2) {\n    return obj1;\n  }\n\n  for(property1 in obj1) {\n    for(property2 in obj2) {\n      if(property1 === property2) {\n        if(typeof obj1[property1] !== 'object' || typeof obj2[property1] !== 'object' || !obj2[property1] || !obj1[property1]) {\n          objToReturn[property1] = obj2[property1];\n        } else {\n          objToReturn[property1] = customMerge(obj1[property1], obj2[property1]);\n        }\n      } else {\n        if(objToReturn[property1] === undefined)\n          objToReturn[property1] = obj1[property1];\n        if(objToReturn[property2] === undefined)\n          objToReturn[property2] = obj2[property2];\n      }\n    }\n  }\n\n  return objToReturn;\n}\n\n/**\n * Resolves the final component style by merging all of the styles that can be\n * applied to a component in the proper order.\n *\n * This function extracts the applicable parts of the theme, parent and element\n * styles, and merges the styles that target the component, and component variants\n * with those styles to get the final style.\n *\n * The styles are merged in the following order, where the styles with the\n * higher index override the styles with the lower one:\n * 1. Theme component style\n * 2. Parent component style\n * 3. Theme style variants specified through styleName\n * 4. Parent style variants specified through styleName\n * 5. Element style passed through the style prop\n *\n * @param componentName The component name ('shoutem.ui.Text')\n * @param styleName Style names ('large rounded')\n * @param themeStyle The theme style that should include the theme and base component style\n * @param parentStyle The style rules inherited from the parent component\n * @param elementStyle The style passed through the style prop of the component\n * @returns {{componentStyle, childrenStyle}} The resolved component and children styles.\n */\nexport function resolveComponentStyle(\n  componentName,\n  styleNames = [],\n  themeStyle = {},\n  parentStyle = {},\n  themeCache\n) {\n\n  // const mergedStyle = _.merge({},\n  //   themeStyle,\n  //   parentStyle['*'],\n  //   parentStyle[componentName],\n  //   ..._.map(styleNames, (sn) => themeStyle[`.${sn}`]),\n  //   ..._.map(styleNames, (sn) => parentStyle[`*.${sn}`]),\n  //   ..._.map(styleNames, (sn) => parentStyle[`${componentName}.${sn}`])\n  // );\n\n  \n\n  let mergedStyle = customMerge(themeStyle, parentStyle[componentName]);\n  styleNames.forEach((sn, index) => {\n    mergedStyle = customMerge(mergedStyle, themeStyle[`${sn}`]);\n  });\n\n  styleNames.forEach((sn, index) => {\n    mergedStyle = customMerge(mergedStyle, parentStyle[`${componentName}${sn}`])\n  });\n\n  // Phase 2: merge the component styles, this step is performed by using the\n  // style from phase 1, so that we are sure that the final style variants are\n  // applied to component style.\n  // const resolvedStyle = _.merge({},\n  //   mergedStyle,\n  //   parentStyle['*'],\n  //   parentStyle[componentName],\n  //   ..._.map(styleNames, (sn) => mergedStyle[`.${sn}`]),\n  //   ..._.map(styleNames, (sn) => parentStyle[`*.${sn}`]),\n  //   ..._.map(styleNames, (sn) => parentStyle[`${componentName}.${sn}`])\n  // );\n\n  let resolvedStyle = customMerge(mergedStyle, parentStyle[componentName]);\n  \n  styleNames.forEach((sn, index) => {\n    resolvedStyle = customMerge(resolvedStyle, mergedStyle[`${sn}`])\n  });\n\n  styleNames.forEach((sn, index) => {\n    resolvedStyle = customMerge(resolvedStyle, parentStyle[`${componentName}${sn}`])\n  });\n\n  return resolvedStyle;\n}\n"]}